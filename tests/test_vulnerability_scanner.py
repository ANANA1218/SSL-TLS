# tests/test_vulnerability_scanner.py

import unittest
from unittest.mock import patch, MagicMock
from OpenSSL import SSL
import sys
sys.path.insert(0, '..')
from vulnerability_scanner import SSLScanner

class TestVulnerabilityScanner(unittest.TestCase):

    @patch('vulnerability_scanner.socket.create_connection')
    @patch('vulnerability_scanner.SSL.Connection')
    def test_analyze_ssl_tls(self, mock_connection, mock_socket):
        mock_socket.return_value = MagicMock()
        mock_connection.return_value = MagicMock()

        mock_connection.return_value.get_peer_certificate.return_value.get_subject.return_value.CN = 'example.com'
        mock_connection.return_value.get_peer_certificate.return_value.get_issuer.return_value.CN = 'CA Authority'
        mock_connection.return_value.get_peer_certificate.return_value.get_version.return_value = 3
        mock_connection.return_value.get_cipher_name.return_value = 'AES256-SHA'
        mock_connection.return_value.get_protocol_version_name.return_value = 'TLSv1.2'

        scanner = SSLScanner('example.com', 443)
        scanner.analyze_ssl_tls()

        self.assertEqual(scanner.result['certificate'], 'example.com')
        self.assertEqual(scanner.result['issuer'], 'CA Authority')
        self.assertEqual(scanner.result['cipher'], 'AES256-SHA')
        self.assertEqual(scanner.result['protocol'], 'TLSv1.2')

    @patch('vulnerability_scanner.SSLScanner.check_heartbleed', return_value=True)
    @patch('vulnerability_scanner.SSLScanner.check_poodle', return_value=True)
    def test_check_vulnerabilities(self, mock_heartbleed, mock_poodle):
        scanner = SSLScanner('example.com', 443)
        scanner.result = {'protocol': 'SSLv3', 'cipher': 'RC4-MD5', 'hostname': 'example.com', 'port': 443}
        scanner.check_vulnerabilities()

        self.assertIn('Protocole obsolète détecté', scanner.vulnerabilities)
        self.assertIn('Suite de chiffrement faible détectée', scanner.vulnerabilities)
        self.assertIn('Vulnérabilité Heartbleed détectée', scanner.vulnerabilities)
        self.assertIn('Vulnérabilité POODLE détectée', scanner.vulnerabilities)

    @patch('vulnerability_scanner.socket.socket')
    def test_check_heartbleed(self, mock_socket):
        mock_socket_instance = mock_socket.return_value
        mock_socket_instance.recv.return_value = b'\x18\x03\x02'
        mock_socket_instance.send.return_value = None

        scanner = SSLScanner('example.com', 443)
        self.assertTrue(scanner.check_heartbleed())

    @patch('vulnerability_scanner.SSL.Connection')
    def test_check_poodle(self, mock_connection):
        mock_connection_instance = mock_connection.return_value
        mock_connection_instance.do_handshake.side_effect = SSL.Error

        scanner = SSLScanner('example.com', 443)
        self.assertFalse(scanner.check_poodle())

    @patch('vulnerability_scanner.nmap.PortScanner')
    def test_scan_ports(self, mock_nmap):
        mock_nmap_instance = mock_nmap.return_value
        mock_nmap_instance.all_hosts.return_value = ['127.0.0.1']
        host_mock = MagicMock()
        host_mock.all_protocols.return_value = ['tcp']
        host_mock['tcp'].keys.return_value = [80, 443]

        mock_nmap_instance.__getitem__.return_value = host_mock

        scanner = SSLScanner('127.0.0.1')
        result = scanner.scan_ports()
        self.assertEqual(result, ['80/tcp', '443/tcp'])

if __name__ == '__main__':
    unittest.main()
