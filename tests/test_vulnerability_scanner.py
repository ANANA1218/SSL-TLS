import unittest
from unittest.mock import patch, MagicMock
from OpenSSL import SSL
import sys
sys.path.insert(0, '..')  # Ajoute le répertoire parent au chemin de recherche
from vulnerability_scanner import analyze_ssl_tls, check_vulnerabilities, check_heartbleed, check_poodle, scan_ports

import ssl

class TestVulnerabilityScanner(unittest.TestCase):
    @patch('vulnerability_scanner.socket.create_connection')
    @patch('vulnerability_scanner.SSL.Connection')
    def test_analyze_ssl_tls(self, mock_connection, mock_socket):
        mock_socket.return_value = MagicMock()
        mock_connection.return_value = MagicMock()

        mock_connection.return_value.get_peer_certificate.return_value.get_subject.return_value.CN = 'example.com'
        mock_connection.return_value.get_peer_certificate.return_value.get_issuer.return_value.CN = 'CA Authority'
        mock_connection.return_value.get_peer_certificate.return_value.get_version.return_value = 3
        mock_connection.return_value.get_cipher_name.return_value = 'AES256-SHA'
        mock_connection.return_value.get_protocol_version_name.return_value = 'TLSv1.2'

        result = analyze_ssl_tls('example.com', 443)
        self.assertEqual(result['certificate'], 'example.com')
        self.assertEqual(result['issuer'], 'CA Authority')
        self.assertEqual(result['cipher'], 'AES256-SHA')
        self.assertEqual(result['protocol'], 'TLSv1.2')

    @patch('vulnerability_scanner.check_heartbleed', return_value=True)
    @patch('vulnerability_scanner.check_poodle', return_value=True)
    def test_check_vulnerabilities(self, mock_heartbleed, mock_poodle):
        result = {'protocol': 'SSLv3', 'cipher': 'RC4-MD5', 'hostname': 'example.com', 'port': 443}
        vulnerabilities = check_vulnerabilities(result)
        self.assertIn('Protocole obsolète détecté', vulnerabilities)
        self.assertIn('Suite de chiffrement faible détectée', vulnerabilities)
        self.assertIn('Vulnérabilité Heartbleed détectée', vulnerabilities)
        self.assertIn('Vulnérabilité POODLE détectée', vulnerabilities)

    @patch('vulnerability_scanner.socket.socket')
    def test_check_heartbleed(self, mock_socket):
        mock_socket_instance = mock_socket.return_value
        mock_socket_instance.recv.return_value = b'\x18\x03\x02'  # Simulation de la réponse Heartbleed
        mock_socket_instance.send.return_value = None

        with patch('ssl.SSLContext.wrap_socket', return_value=mock_socket_instance):
            context = ssl.create_default_context()
            with patch('ssl.create_default_context', return_value=context):
                result = check_heartbleed('example.com', 443)
                self.assertTrue(result)

    @patch('vulnerability_scanner.SSL.Connection')
    def test_check_poodle(self, mock_connection):
        mock_connection_instance = mock_connection.return_value
        mock_connection_instance.do_handshake.side_effect = SSL.Error

        result = check_poodle('example.com', 443)
        self.assertFalse(result)

    @patch('vulnerability_scanner.nmap.PortScanner')
    def test_scan_ports(self, mock_nmap):
        mock_nmap_instance = mock_nmap.return_value
        mock_nmap_instance.all_hosts.return_value = ['127.0.0.1']
        host_mock = MagicMock()
        host_mock.all_protocols.return_value = ['tcp']
        host_mock['tcp'].keys.return_value = [80, 443]

        mock_nmap_instance.__getitem__.return_value = host_mock

        result = scan_ports('127.0.0.1')
        self.assertEqual(result, ['80/tcp', '443/tcp'])

if __name__ == '__main__':
    unittest.main()
