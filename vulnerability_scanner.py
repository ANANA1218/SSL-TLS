import ssl
import socket
import struct
from OpenSSL import SSL
import nmap
import os

class SSLScanner:
    """
    Classe principale pour scanner les vulnérabilités SSL/TLS.
    Cette classe encapsule toutes les fonctionnalités nécessaires pour analyser
    la sécurité d'une connexion SSL/TLS sur un hôte donné.
    """

    def __init__(self, hostname, port=443):
        """
        Initialise le scanner avec un nom d'hôte et un port.
        
        :param hostname: Le nom d'hôte à scanner (string)
        :param port: Le port à scanner (int, par défaut 443 pour HTTPS)
        """
        self.hostname = hostname  # Stocke le nom d'hôte cible
        self.port = port  # Stocke le port cible
        self.result = None  # Contiendra les résultats de l'analyse SSL/TLS
        self.vulnerabilities = []  # Liste pour stocker les vulnérabilités détectées

    def analyze_ssl_tls(self):
        """
        Analyse la configuration SSL/TLS de l'hôte cible.
        Cette méthode établit une connexion SSL/TLS et récupère les informations
        sur le certificat, le chiffrement et le protocole utilisés.
        """
        # Crée un contexte SSL
        context = SSL.Context(SSL.SSLv23_METHOD)
        # Établit une connexion TCP
        sock = socket.create_connection((self.hostname, self.port))
        # Crée une connexion SSL à partir de la socket
        connection = SSL.Connection(context, sock)
        # Définit le nom d'hôte pour SNI (Server Name Indication)
        connection.set_tlsext_host_name(self.hostname.encode())
        # Configure la connexion en mode client
        connection.set_connect_state()
        connection.do_handshake()

        # Récupère les informations sur le certificat, le chiffrement et le protocole
        cert = connection.get_peer_certificate()
        cipher = connection.get_cipher_name()
        protocol = connection.get_protocol_version_name()

        # Stocke les résultats
        self.result = {
            "hostname": self.hostname,
            "port": self.port,
            "certificate": cert.get_subject().CN,  # Nom commun du sujet du certificat
            "issuer": cert.get_issuer().CN,  # Nom commun de l'émetteur du certificat
            "version": cert.get_version(),  # Version du certificat
            "cipher": cipher,  # Suite de chiffrement utilisée
            "protocol": protocol  # Version du protocole SSL/TLS
        }

    def check_vulnerabilities(self):
        """
        Vérifie les vulnérabilités SSL/TLS connues.
        Cette méthode analyse les résultats de l'analyse SSL/TLS pour détecter
        des configurations potentiellement dangereuses ou des vulnérabilités connues.
        """
        # Vérifie si un protocole obsolète est utilisé
        if self.result["protocol"] in ["SSLv2", "SSLv3"]:
            self.vulnerabilities.append("Protocole obsolète détecté")
        
        # Liste des suites de chiffrement 
        weak_ciphers = ["RC4", "DES", "MD5"]
        # Vérifie si une suite de chiffrement est utilisée
        if any(cipher in self.result["cipher"] for cipher in weak_ciphers):
            self.vulnerabilities.append("Suite de chiffrement faible détectée")
        
        # Vérifie la présence de la vulnérabilité Heartbleed
        if self.check_heartbleed():
            self.vulnerabilities.append("Vulnérabilité Heartbleed détectée")
        
        # Vérifie la présence de la vulnérabilité POODLE
        if self.check_poodle():
            self.vulnerabilities.append("Vulnérabilité POODLE détectée")

    def check_heartbleed(self):
        """
        Vérifie la présence de la vulnérabilité Heartbleed.
        Cette méthode tente d'exploiter la vulnérabilité Heartbleed pour déterminer
        si le serveur y est vulnérable.
        
        :return: True si la vulnérabilité est détectée, False sinon
        """
        # Crée une socket TCP
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # Se connecte à l'hôte cible
        s.connect((self.hostname, self.port))
        # Enveloppe la socket dans une connexion SSL
        s = ssl.wrap_socket(s, ssl_version=ssl.PROTOCOL_TLSv1)
        
        hb = b'\x18\x03\x02\x00\x03\x01\x40\x00'
        s.send(hb)
        
        try:
            # Tente de recevoir une réponse
            data = s.recv(1024)
            # Si la réponse est plus longue que prévu, c'est probablement vulnérable
            if len(data) > 3:
                return True
        except:
            pass  # Ignore les erreurs
        finally:
            s.close()  # Ferme toujours la connexion
        return False

    def check_poodle(self):
        """
        Vérifie la présence de la vulnérabilité POODLE.
        Cette méthode tente d'établir une connexion SSLv3 pour déterminer
        si le serveur est vulnérable à POODLE.
        
        :return: True si la vulnérabilité est détectée, False sinon
        """
        # Crée un contexte SSL qui n'autorise que SSLv3
        context = SSL.Context(SSL.SSLv23_METHOD)
        context.set_options(SSL.OP_NO_SSLv2 | SSL.OP_NO_TLSv1)
        
        # Établit une connexion TCP
        s = socket.create_connection((self.hostname, self.port))
        # Crée une connexion SSL
        connection = SSL.Connection(context, s)
        connection.set_tlsext_host_name(self.hostname.encode())
        connection.set_connect_state()
        
        try:
            connection.do_handshake()
            return True  # Si réussi, le serveur est vulnérable
        except SSL.Error:
            return False  # Si échoué, le serveur n'est probablement pas vulnérable
        finally:
            connection.close()  # Ferme la connexion

    def generate_report(self):
        """
        Génère un rapport détaillé des résultats du scan.
        Cette méthode formate les résultats de l'analyse et les vulnérabilités
        détectées dans un rapport lisible.
        
        :return: Une chaîne de caractères contenant le rapport
        """
        # Formatage du rapport
        report = f"""
SSL/TLS Vulnerability Scan Report
---------------------------------
Target: {self.result['hostname']}:{self.result['port']}
Certificate: {self.result['certificate']}
Issuer: {self.result['issuer']}
Protocol: {self.result['protocol']}
Cipher Suite: {self.result['cipher']}

Vulnerabilities:
{chr(10).join('- ' + v for v in self.vulnerabilities) if self.vulnerabilities else "Aucune vulnérabilité détectée"}

Recommendations:
- Mettez à jour vers la dernière version de TLS
- Utilisez des suites de chiffrement fortes
- Désactivez les protocoles obsolètes
- Appliquez les correctifs de sécurité pour Heartbleed et POODLE si détectés
"""
        return report

    def scan_ports(self):
        """
        Scanne les ports ouverts sur l'hôte cible.
        Cette méthode utilise nmap pour effectuer un scan de ports complet.
        
        :return: Une liste des ports ouverts
        """
        # Initialise le scanner nmap
        nm = nmap.PortScanner()
        # Effectue un scan de tous les ports
        nm.scan(self.hostname, arguments='-p- --open')
        open_ports = []
        # Parcourt les résultats du scan
        for host in nm.all_hosts():
            for proto in nm[host].all_protocols():
                lport = nm[host][proto].keys()
                for port in lport:
                    open_ports.append(f"{port}/{proto}")
        return open_ports

    def run(self):
        """
        Exécute le scan complet et affiche les résultats.
        Cette méthode orchestre l'ensemble du processus de scan.
        """
        print(f"Analyse de {self.hostname}:{self.port}...")
        
        try:
            # Effectue l'analyse SSL/TLS
            self.analyze_ssl_tls()
            # Vérifie les vulnérabilités
            self.check_vulnerabilities()
            # Génère et affiche le rapport
            report = self.generate_report()
            print(report)

            # Effectue un scan de ports
            print("Scan des ports ouverts...")
            open_ports = self.scan_ports()
            print("Ports ouverts :")
            for port in open_ports:
                print(f"- {port}")

        except Exception as e:
            # Gère les erreurs potentielles
            print(f"Une erreur s'est produite : {e}")

def main():
    """
    Fonction principale qui initialise et exécute le scanner.
    Cette fonction récupère les paramètres d'environnement et lance le scan.
    """
    # Récupère le nom d'hôte depuis les variables d'environnement ou utilise une valeur par défaut
    hostname = os.environ.get('HOSTNAME', 'example.com')
    # Récupère le port depuis les variables d'environnement ou utilise une valeur par défaut
    port = int(os.environ.get('PORT', 443))

    # Crée une instance du scanner
    scanner = SSLScanner(hostname, port)
    # Exécute le scan
    scanner.run()

if __name__ == "__main__":
    main()
